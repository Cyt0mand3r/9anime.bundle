#!/usr/bin/env python

"""9anime.to Service Code"""

from urllib import urlencode
import common as Common
from network import Network
from metadata import Metadata

RE_NORM = Regex(r'(https?://(?:www\.)?\w+\.\w+)/watch/.+\.(\w+)/(\w+)')
SERVER_DICT = {'9anime.1': 1, '9anime.2': 2, 'Openload': 3}

####################################################################################################
def NormalizeURL(url):

    return url.split('?')[0]

####################################################################################################
def MetadataObjectForURL(url):

    meta = Metadata(url)
    if meta.kind_simple == 'Movie':
        return MovieObject(
            title=meta.show_name,
            source_title='9anime',
            rating=meta.score,
            duration=meta.duration,
            genres=meta.genres,
            tags=meta.tags,
            originally_available_at=meta.oaa,
            year=meta.year,
            thumb=Resource.ContentsOfURLWithFallback([meta.thumb, meta.thumb_fallback]),
            art=Resource.ContentsOfURLWithFallback([meta.art, meta.art_fallback]),
            summary=meta.summary
            )
    ep = meta.episode(ser_num=SERVER_DICT[Prefs['server']])
    Log("* ep_dict = {}".format(ep))
    return EpisodeObject(
        title=ep['title'] if ep else meta.show_name,
        show=meta.show_name,
        season=int(ep['season']) if ep else 0,
        index=int(ep['epn']) if ep else 0,
        source_title='9anime',
        rating=meta.score,
        duration=meta.duration,
        tags=meta.tags,
        originally_available_at=meta.oaa,
        #year=meta.year,
        thumb=Resource.ContentsOfURLWithFallback([meta.thumb, meta.thumb_fallback]),
        art=Resource.ContentsOfURLWithFallback([meta.art, meta.art_fallback]),
        summary=meta.summary
        )

####################################################################################################
def MediaObjectsForURL(url):

    return [
        MediaObject(
            video_resolution=res,
            container=Container.MP4,
            video_codec=VideoCodec.H264,
            audio_codec=AudioCodec.AAC,
            audio_channels=2,
            optimized_for_streaming=True,
            parts=[
                PartObject(key=Callback(PlayVideo, url=url, res=res))
                ],
            ) for res in ('1080', '720', '480', '360')
        ]

####################################################################################################
@indirect
def PlayVideo(url, res='720', **kwargs):

    r = RE_NORM.search(url)
    if not r:
        raise Ex.MediaNotAvailable

    base_url = r.group(1)
    sid = r.group(2)
    vid = r.group(3)
    data_url = base_url + '/ajax/episode/info?id=' + vid

    http_headers = {'Referer': url, 'User-Agent': Common.USER_AGENT}

    # token handler
    cookies = Network.get_cookies()
    if not cookies:
        for u in [data_url, base_url, url]:
            Network.unCache(u)
        cookies = Network.get_cookies()
    if not cookies:
        Log.Error(u"* Cannot handle cookies for {}.  Contact Twoure with logs.".format(data_url))
        raise Ex.MediaNotAvailable

    http_headers['Cookie'] = cookies
    Log("* 9anime Cookies for {}\n{}".format(url, http_headers['Cookie']))

    # grabber handler
    resp = Network.Request(data_url, http_headers)
    data = resp.json()
    if ('error' in data.keys()) and data['error']:
        Log.Error(u"* 9anime Grabber Error: {}".format(data['error']))
        raise Ex.MediaNotAvailable
    grabber = clean_url(data['grabber'] + '?' + urlencode(data['params']))

    # streams handler
    resp = Network.Request(grabber, http_headers)
    streams = resp.json()
    if ('error' in streams.keys()) and streams['error']:
        Log.Error(u"* 9anime Video Error: {}".format(streams['error']))
        raise Ex.MediaNotAvailable
    vurls = [{'label': int(s['label'][:-1]), 'file': s['file']} for s in streams['data'] if s['type'] == 'mp4']
    Log.Debug("* 9anime Video Sources: {}".format(vurls))

    # Mark watched
    if Prefs['login']:
        values = {
            'username': Prefs['username'],
            'password': Prefs['password'],
            'remember': '1'
            }
        res = Network.Request(base_url+'/user/login', values=values, method='POST')
        http_headers['Cookie'] = Network.cookies_from_res(res)

        Network.Request(base_url+'/user/ajax/playing', values={"data[%s]" %sid: vid}, headers=http_headers)
        Network.unCache(base_url+'/user/ajax/playing')

        if Prefs['lswitch']:
            html = Network.ElementFromURL(url.rsplit("/",1)[0])
            next_episode_number = int(html.xpath('//div[@id="servers"]//a[@href="%s"]' %url.split(".to",1)[1])[0].get('data-base')) + 1
            Log("next episode number: {}".format(next_episode_number))
            try:
                html.xpath("//div[@id='servers']/div[@class='server row'][1]//li/a[@data-base='%s']/@href" %str(next_episode_number))[0]
                Log("next episode available")
                Network.unCache(base_url + "/user/ajax/edit-watchlist?folder=watching&id=%s&R=1" %sid)
                Network.Request(base_url + "/user/ajax/edit-watchlist?folder=watching&id=%s&R=1" %sid, headers=http_headers)
            except:
                status = html.xpath("//dl[@class='meta col-sm-12'][1]/dd[6]/text()")[0].strip()
                Log("no next episode")
                if (status.lower() == "airing"):
                    Network.unCache(base_url + "/user/ajax/edit-watchlist?folder=watching&id=%s&R=1" %sid)
                    Network.Request(base_url + "/user/ajax/edit-watchlist?folder=watching&id=%s&R=1" %sid, headers=http_headers)
                else:
                    Network.unCache(base_url + "/user/ajax/edit-watchlist?folder=watched&id=%s&R=1" %sid)
                    Network.Request(base_url + "/user/ajax/edit-watchlist?folder=watched&id=%s&R=1" %sid, headers=http_headers)

    vurl = None
    for s in Util.ListSortedByKey(vurls, 'label'):
        vurl = s['file']
        q = s['label']
        if s['label'] == int(res):
            break
        elif s['label'] > int(res):
            break

    if vurl:
        Log.Debug('* PlayVideo URL = {} | {}'.format(q, vurl))
        return IndirectResponse(VideoClipObject, key=vurl)

    raise Ex.MediaNotAvailable

####################################################################################################
def clean_url(url):
    if url.startswith('//'):
        url = 'https:' + url
    elif url.startswith('/'):
        url = Common.BASE_URL + url
    return url
