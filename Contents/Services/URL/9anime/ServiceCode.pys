#!/usr/bin/env python

"""9anime.to Service Code"""

from urllib import urlencode
import common as Common
from network import Network
from metadata import Metadata

from lxml import html as HTML

RE_NORM = Regex(r'(https?://(?:www\.)?\w+\.\w+)/watch/.+\.(\w+)/(\w+)')
SERVER_DICT = {'9anime.1': 1, '9anime.2': 2, 'Openload': 3}

####################################################################################################
def NormalizeURL(url):

    return url.split('?')[0]

####################################################################################################
def MetadataObjectForURL(url):

    meta = Metadata(url)
    if meta.kind_simple == 'Movie':
        return MovieObject(
            title=meta.show_name,
            source_title='9anime',
            rating=meta.score,
            duration=meta.duration,
            genres=meta.genres,
            tags=meta.tags,
            originally_available_at=meta.oaa,
            year=meta.year,
            thumb=Resource.ContentsOfURLWithFallback([meta.thumb, meta.thumb_fallback]),
            art=Resource.ContentsOfURLWithFallback([meta.art, meta.art_fallback]),
            summary=meta.summary
            )
    ep = meta.episode(ser_num=SERVER_DICT[Prefs['server']])
    Log("* ep_dict = {}".format(ep))
    return EpisodeObject(
        title=ep['title'] if ep else meta.show_name,
        show=meta.show_name,
        season=int(ep['season']) if ep else 0,
        index=int(ep['epn']) if ep else 0,
        source_title='9anime',
        rating=meta.score,
        duration=meta.duration,
        tags=meta.tags,
        originally_available_at=meta.oaa,
        #year=meta.year,
        thumb=Resource.ContentsOfURLWithFallback([meta.thumb, meta.thumb_fallback]),
        art=Resource.ContentsOfURLWithFallback([meta.art, meta.art_fallback]),
        summary=meta.summary
        )

####################################################################################################
def MediaObjectsForURL(url):

    return [
        MediaObject(
            video_resolution=res,
            container=Container.MP4,
            video_codec=VideoCodec.H264,
            audio_codec=AudioCodec.AAC,
            audio_channels=2,
            optimized_for_streaming=True,
            parts=[
                PartObject(key=Callback(PlayVideo, url=url, res=res))
                ],
            ) for res in ('1080', '720', '480', '360')
        ]

####################################################################################################
@indirect
def PlayVideo(url, res='720', **kwargs):

    r = RE_NORM.search(url)
    if not r:
        raise Ex.MediaNotAvailable

    base_url = r.group(1)
    sid = r.group(2)
    vid = r.group(3)
    data_url = base_url + '/ajax/episode/info?id=' + vid

    http_headers = {'Referer': url, 'User-Agent': Common.USER_AGENT}

    # token handler
    http_headers['Cookie'] = Network.get_cookies()
    Log("* 9anime Cookies for {}\n{}".format(url, http_headers['Cookie']))

    # grabber handler
    resp = Network.Request(data_url, http_headers)
    data = resp.json()
    grabber = clean_url(data['grabber'] + '?' + urlencode(data['params']))

    # streams handler
    resp = Network.Request(grabber, http_headers)
    streams = resp.json()
    vurls = [{'label': int(s['label'][:-1]), 'file': s['file']} for s in streams['data'] if s['type'] == 'mp4']
    Log.Debug("* 9anime Video Sources: {}".format(vurls))

    # Mark watched
    if Prefs['Login']:
        values = {
            'username': Prefs['Username'],
            'password': Prefs['Password'],
            'remember': '1'
        }
        page = Network.Request(base_url + '/user/login', values= values, method = 'POST')
        cookies = Network.get_cookies_page(page)
        page = Network.Request(base_url + '/user/ajax/playing', values= {"data[" + sid + "]":vid}, headers = {'referer': url, 'cookie': cookies}, method = 'POST')
        Network.unCache(base_url + '/user/ajax/playing')
        
        if Prefs['ListSwitching']:
            page = Network.Request(url.rsplit("/",1)[0])
            page_data = HTML.fromstring(page.text)
            next_episode_number = int(page_data.xpath('//div[@id="servers"]//a[@href="' + url.split(".to",1)[1] + '"]')[0].get('data-base')) + 1
            Log("next episode number: {}".format(next_episode_number))
            try:
                page_data.xpath("//div[@id='servers']/div[@class='server row'][1]//li/a[@data-base='" + str(next_episode_number) + "']/@href")[0]
                Log("next episode available")
                Network.unCache(base_url + "/user/ajax/edit-watchlist?folder=watching&id=" + sid + "&R=1")
                Network.Request(base_url + "/user/ajax/edit-watchlist?folder=watching&id=" + sid + "&R=1", headers = {'referer': url, 'cookie': cookies})
            except:
                status = page_data.xpath("//dl[@class='meta col-sm-12'][1]/dd[6]/text()")[0].strip()
                Log("no next episode")
                if status == "Airing":
                    Network.unCache(base_url + "/user/ajax/edit-watchlist?folder=watching&id=" + sid + "&R=1")
                    Network.Request(base_url + "/user/ajax/edit-watchlist?folder=watching&id=" + sid + "&R=1", headers = {'referer': url, 'cookie': cookies})
                else:
                    Network.unCache(base_url + "/user/ajax/edit-watchlist?folder=watched&id=" + sid + "&R=1")
                    Network.Request(base_url + "/user/ajax/edit-watchlist?folder=watched&id=" + sid + "&R=1", headers = {'referer': url, 'cookie': cookies})

    vurl = None
    for s in Util.ListSortedByKey(vurls, 'label'):
        vurl = s['file']
        q = s['label']
        if s['label'] == int(res):
            break
        elif s['label'] > int(res):
            break

    if vurl:
        Log.Debug('* PlayVideo URL = {} | {}'.format(q, vurl))
        return IndirectResponse(VideoClipObject, key=vurl)

    raise Ex.MediaNotAvailable

####################################################################################################
def clean_url(url):
    if url.startswith('//'):
        url = 'https:' + url
    elif url.startswith('/'):
        url = Common.BASE_URL + url
    return url